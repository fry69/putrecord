import { AtpAgent } from "@atproto/api";
import * as TID from "@atcute/tid";
import { walk } from "@std/fs";
import state from "./state.json" with { type: "json" };

// Types for better type safety
interface StateFile {
  name: string;
  rkey: string;
}

interface State {
  pds_url: string;
  did: string;
  handle: string;
  collection: string;
  path: string;
  files: StateFile[];
}

interface BlogRecord {
  content: string;
  createdAt: string;
  [key: string]: unknown;
}

// Check state for basic consistency
const requiredFields = [
  "pds_url",
  "did",
  "handle",
  "collection",
  "path",
  "files",
];

for (const key of requiredFields) {
  if (!(key in state)) {
    console.error(`Missing required field state.json: ${key}`);
    Deno.exit(1);
  }
}

// Load environment variables
function getRequiredEnv(key: string): string {
  const value = Deno.env.get(key);
  if (!value) {
    console.error(`Missing required environment variable: ${key}`);
    Deno.exit(1);
  }
  return value;
}

// Helper function to remove autogenerated footer
function removeFooter(content: string): string {
  // Look for the footer pattern and remove it
  const footerRegex = /\n\n---\n\*Last updated: [^*]+\*$/;
  return content.replace(footerRegex, "");
}

const APP_PASSWORD = getRequiredEnv("APP_PASSWORD");
const workingState: State = structuredClone(state);

console.log("Starting AT Protocol blog sync...");

// 1. Authenticate using AtpAgent
const agent = new AtpAgent({ service: workingState.pds_url });

try {
  console.log(`Authenticating as ${workingState.handle}...`);
  await agent.login({
    identifier: workingState.handle,
    password: APP_PASSWORD,
  });
  console.log("Authentication successful!");
} catch (error) {
  console.error("Login failed:", error);
  Deno.exit(1);
}

// 2. Get all markdown files from the specified path
console.log(`Scanning for markdown files in ${workingState.path}/...`);
const markdownFiles: string[] = [];

try {
  for await (const entry of walk(workingState.path, { exts: ["md"] })) {
    if (entry.isFile) {
      markdownFiles.push(entry.name);
    }
  }
  console.log(
    `Found ${markdownFiles.length} markdown files: ${markdownFiles.join(", ")}`,
  );
} catch (error) {
  console.error(`Failed to scan directory ${workingState.path}:`, error);
  Deno.exit(1);
}

// 3. Process each markdown file
for (const filename of markdownFiles) {
  console.log(`\nProcessing ${filename}...`);
  const filePath = `${workingState.path}/${filename}`;

  // Read file content
  let fileContent: string;
  try {
    fileContent = await Deno.readTextFile(filePath);
  } catch (error) {
    console.error(`Failed to read ${filename}:`, error);
    continue;
  }

  // Check if file already exists in state
  const existingFile = workingState.files.find((f) => f.name === filename);

  if (existingFile) {
    console.log(
      `File ${filename} found in state with rkey: ${existingFile.rkey}`,
    );

    // Fetch existing record from PDS
    try {
      const getRes = await agent.com.atproto.repo.getRecord({
        repo: workingState.did,
        collection: workingState.collection,
        rkey: existingFile.rkey,
      });

      const existingRecord = getRes.data.value as unknown as BlogRecord;
      const existingContent = removeFooter(existingRecord.content || "");

      // Compare content (without footer)
      if (existingContent === fileContent) {
        console.log(`Content for ${filename} is unchanged, skipping update`);
        continue;
      }

      console.log(`Content for ${filename} has changed, updating...`);

      // Update existing record
      const currentDateTime = new Date().toISOString();
      const footer = `\n\n---\n*Last updated: ${currentDateTime}*`;
      existingRecord.content = fileContent + footer;

      await agent.com.atproto.repo.putRecord({
        repo: workingState.did,
        collection: workingState.collection,
        rkey: existingFile.rkey,
        record: existingRecord,
      });

      console.log(
        `Successfully updated ${filename} (rkey: ${existingFile.rkey})`,
      );
    } catch (error) {
      console.error(`Failed to update existing record for ${filename}:`, error);
      continue;
    }
  } else {
    console.log(`File ${filename} is new, creating record...`);

    // Create new record
    try {
      const rkey = TID.now();
      const currentDateTime = new Date().toISOString();
      const footer = `\n\n---\n*Last updated: ${currentDateTime}*`;

      const newRecord = {
        content: fileContent + footer,
        createdAt: currentDateTime,
      };

      await agent.com.atproto.repo.putRecord({
        repo: workingState.did,
        collection: workingState.collection,
        rkey: rkey,
        record: newRecord,
      });

      // Add to state
      workingState.files.push({
        name: filename,
        rkey: rkey,
      });

      console.log(
        `Successfully created new record for ${filename} (rkey: ${rkey})`,
      );
    } catch (error) {
      console.error(`Failed to create new record for ${filename}:`, error);
      continue;
    }
  }
}

// 4. Write updated state back to state.json
try {
  console.log("\nSaving updated state to state.json...");
  await Deno.writeTextFile(
    "./state.json",
    JSON.stringify(workingState, null, 2),
  );
  console.log("State saved successfully!");
} catch (error) {
  console.error("Failed to save state:", error);
  Deno.exit(1);
}

console.log("\nSync completed successfully!");
